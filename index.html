<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>–í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –ø–∞–∑–ª</title>

<style>
  body {
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
  }

  #controls {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    margin-bottom: 20px;
    align-items: center;
  }

  #puzzle {
    display: grid;
    gap: 2px;
    border: 2px solid #000;
    padding: 5px;
    touch-action: none; /* –¥–ª—è –ª—É—á—à–µ–π —Ä–∞–±–æ—Ç—ã touch */
  }

  .cell {
    position: relative;
    overflow: hidden;
    background: #eee;
  }

  .piece {
    width: 100%;
    height: 100%;
    background-size: cover;
    cursor: grab;
    user-select: none;
    transition: transform 150ms ease, border-color 120ms;
    box-sizing: border-box;
    border: 2px solid transparent;
  }

  .piece.dragging {
    opacity: 0.6;
    cursor: grabbing;
    transform: scale(1.02);
    z-index: 10;
  }

  .piece.selected {
    outline: 3px dashed #666;
  }

  #message {
    margin-top: 12px;
    font-weight: bold;
  }

  #previewContainer {
    margin-top: 15px;
    display: none;
    text-align: center;
  }

  .previewPiece {
    display: inline-block;
    border: 2px solid #444;
    margin: 1px;
    background-size: cover;
  }

  /* –ø–æ–¥—Å–∫–∞–∑–∫–∞ –ø—Ä–∏ dragover */
  .cell.drop-target {
    box-shadow: inset 0 0 0 3px rgba(0, 120, 215, 0.25);
  }
</style>
</head>

<body>

<h1>–í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –ø–∞–∑–ª</h1>

<div id="controls">
  <input type="file" id="imageUpload" accept="image/*">
  <label>–®–∏—Ä–∏–Ω–∞:
    <input type="number" id="cols" min="1" max="20" value="5" style="width:60px">
  </label>
  <label>–í—ã—Å–æ—Ç–∞:
    <input type="number" id="rows" min="1" max="20" value="6" style="width:60px">
  </label>
  <label>
    <input type="checkbox" id="enableCheck" checked>
    –ü—Ä–æ–≤–µ—Ä—è—Ç—å –ø–æ–∑–∏—Ü–∏–∏ –¥–µ—Ç–∞–ª–µ–π
  </label>
  <button id="generate">–°–æ–∑–¥–∞—Ç—å –ø–∞–∑–ª</button>
  <button id="shuffleBtn" disabled>–ü–µ—Ä–µ–º–µ—à–∞—Ç—å</button>
  <button id="previewBtn">–ü–æ–∫–∞–∑–∞—Ç—å –∫–∞—Ä—Ç–∏–Ω–∫—É</button>
</div>

<div id="previewContainer">
  <h3>–ö–∞–∫ –¥–æ–ª–∂–Ω–æ –≤—ã–≥–ª—è–¥–µ—Ç—å:</h3>
  <div id="previewPuzzle"></div>
</div>

<div id="puzzle"></div>
<div id="message"></div>
<h3 id="timer">–í—Ä–µ–º—è: 0:00:000 </h3>

<script>
const imgInput = document.getElementById('imageUpload');
const generateBtn = document.getElementById('generate');
const shuffleBtn = document.getElementById('shuffleBtn');
const previewBtn = document.getElementById('previewBtn');
const enableCheck = document.getElementById('enableCheck');
const puzzle = document.getElementById('puzzle');
const previewContainer = document.getElementById('previewContainer');
const previewPuzzle = document.getElementById('previewPuzzle');
const message = document.getElementById('message');
const timerDisplay = document.getElementById('timer');

let imageURL = '';
let cols = 5, rows = 6;
let pieceWidth = 100, pieceHeight = 100;
let cells = [];
let started = false;
let startTime = null;
let timer = null;
let pieceIdCounter = 0;

/* ===== –ó–ê–ì–†–£–ó–ö–ê –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–Ø ===== */
imgInput.addEventListener('change', e => {
  if (e.target.files && e.target.files[0]) {
    imageURL = URL.createObjectURL(e.target.files[0]);
  }
});

/* ===== –°–û–ó–î–ê–ù–ò–ï –ü–ê–ó–õ–ê ===== */
generateBtn.addEventListener('click', () => {
  if (!imageURL) return alert('–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ');

  cols = Math.max(1, Math.min(20, +document.getElementById('cols').value || 1));
  rows = Math.max(1, Math.min(20, +document.getElementById('rows').value || 1));

  // –†–∞–∑–º–µ—Ä "—Ö–æ–ª—Å—Ç–∞" —Ñ–∏–∫—Å–∏—Ä—É–µ–º 500x500 –¥–ª—è —Ä–∞—Å—á—ë—Ç–∞ —Ñ–æ–Ω–∞, –Ω–æ —Å–µ—Ç–∫–∞ –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ—Ç—Å—è
  const canvasSize = 500;
  pieceWidth = Math.floor(canvasSize / cols);
  pieceHeight = Math.floor(canvasSize / rows);

  puzzle.innerHTML = '';
  cells = [];
  pieceIdCounter = 0;

  puzzle.style.display = 'grid';
  puzzle.style.gridTemplateColumns = `repeat(${cols}, ${pieceWidth}px)`;
  puzzle.style.gridTemplateRows = `repeat(${rows}, ${pieceHeight}px)`;

  // –°–æ–∑–¥–∞–µ–º —è—á–µ–π–∫–∏ –∏ –¥–µ—Ç–∞–ª–∏
  for (let i = 0; i < cols * rows; i++) {
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.style.width = pieceWidth + 'px';
    cell.style.height = pieceHeight + 'px';
    cell.dataset.index = i;

    // –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è dragover/drop
    cell.addEventListener('dragover', e => {
      e.preventDefault();
      cell.classList.add('drop-target');
    });
    cell.addEventListener('dragleave', () => cell.classList.remove('drop-target'));
    cell.addEventListener('drop', onDropOnCell);

    const piece = document.createElement('div');
    piece.className = 'piece';
    piece.draggable = true;
    piece.id = 'piece-' + (pieceIdCounter++);

    const r = Math.floor(i / cols);
    const c = i % cols;

    piece.style.backgroundImage = `url(${imageURL})`;
    piece.style.backgroundSize = `${cols * pieceWidth}px ${rows * pieceHeight}px`;
    piece.style.backgroundPosition = `-${c * pieceWidth}px -${r * pieceHeight}px`;
    piece.dataset.correct = i;

    // drag events (desktop)
    piece.addEventListener('dragstart', e => {
      e.dataTransfer.setData('text/plain', piece.id);
      piece.classList.add('dragging');
      if (!started) startTimer();
    });
    piece.addEventListener('dragend', () => {
      piece.classList.remove('dragging');
      document.querySelectorAll('.cell.drop-target').forEach(el => el.classList.remove('drop-target'));
    });

    // click selection (fallback)
    piece.addEventListener('click', e => {
      e.stopPropagation();
      // –µ—Å–ª–∏ –∫–ª–∏–∫ –Ω–∞ —ç–ª–µ–º–µ–Ω—Ç ‚Äî –≤—ã–¥–µ–ª–∏–º –∏ –ø–æ–∑–≤–æ–ª–∏–º –∫–ª–∏–∫ –ø–æ —è—á–µ–π–∫–µ –¥–ª—è –æ–±–º–µ–Ω–∞
      toggleSelect(piece);
    });

    // touch support (mobile)
    piece.addEventListener('touchstart', onTouchStart, {passive:false});
    piece.addEventListener('touchmove', onTouchMove, {passive:false});
    piece.addEventListener('touchend', onTouchEnd);

    cell.appendChild(piece);
    cells.push(cell);
    puzzle.appendChild(cell);
  }

  shuffle(); // –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏
  shuffleBtn.disabled = false;
  resetTimer();
  message.textContent = '';
});

/* ===== –ü–ï–†–ï–ú–ï–®–ò–í–ê–ù–ò–ï ===== */
shuffleBtn.addEventListener('click', shuffle);

function shuffle() {
  const pieces = cells.map(c => c.firstChild);
  // Fisher-Yates –¥–ª—è –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è
  for (let i = pieces.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
  }
  cells.forEach((cell, i) => cell.appendChild(pieces[i]));
  // —Å–±—Ä–æ—Å –æ–±–≤–æ–¥–æ–∫
  document.querySelectorAll('.piece').forEach(p => p.style.border = '2px solid transparent');
  message.textContent = '';
}

/* ===== –ü–û–ú–ï–©–ï–ù–ò–ï –ü–†–ò DROP ===== */
function onDropOnCell(e) {
  e.preventDefault();
  this.classList.remove('drop-target');
  const draggedId = e.dataTransfer.getData('text/plain');
  const dragged = document.getElementById(draggedId);
  if (!dragged) return;

  const targetPiece = this.firstChild;
  const sourceCell = dragged.parentElement;

  // –µ—Å–ª–∏ —Ü–µ–ª—å ‚Äî —Ç–∞ –∂–µ —è—á–µ–π–∫–∞, –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
  if (sourceCell === this) return;

  // –º–µ–Ω—è–µ–º –º–µ—Å—Ç–∞–º–∏ —ç–ª–µ–º–µ–Ω—Ç—ã
  sourceCell.appendChild(targetPiece);
  this.appendChild(dragged);

  // –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ: —É–±—Ä–∞—Ç—å –≤—ã–±–æ—Ä / –∫–ª–∞—Å—Å
  dragged.classList.remove('selected', 'dragging');
  if (enableCheck.checked) checkPositions();
  else if (isSolved()) finishPuzzle();
}

/* ===== –í–´–î–ï–õ–ï–ù–ò–ï –î–ï–¢–ê–õ–ò –ö–õ–ò–ö–û–ú ===== */
let selectedPiece = null;
function toggleSelect(piece) {
  if (selectedPiece) selectedPiece.classList.remove('selected');
  if (selectedPiece === piece) {
    selectedPiece = null;
  } else {
    selectedPiece = piece;
    piece.classList.add('selected');
  }

  // –ø–µ—Ä–≤—ã–π —Ö–æ–¥ –∑–∞–ø—É—Å–∫–∞–µ—Ç —Ç–∞–π–º–µ—Ä
  if (!started && selectedPiece) startTimer();
}

/* ===== –ö–õ–ò–ö –ü–û –Ø–ß–ï–ô–ö–ï –î–õ–Ø –û–ë–ú–ï–ù–ê (–ø—Ä–∏ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–π –¥–µ—Ç–∞–ª–∏) ===== */
puzzle.addEventListener('click', e => {
  const cell = e.target.closest('.cell');
  if (!cell || !selectedPiece) return;

  const targetPiece = cell.firstChild;
  const sourceCell = selectedPiece.parentElement;

  if (targetPiece === selectedPiece) return;

  sourceCell.appendChild(targetPiece);
  cell.appendChild(selectedPiece);

  selectedPiece.classList.remove('selected');
  selectedPiece = null;

  if (enableCheck.checked) checkPositions();
  else if (isSolved()) finishPuzzle();
});

/* ===== –ü–†–û–í–ï–†–ö–ê ===== */
function checkPositions() {
  let solved = true;

  cells.forEach((cell, i) => {
    const piece = cell.firstChild;
    if (+piece.dataset.correct === i) {
      piece.style.border = '2px solid green';
    } else {
      piece.style.border = '2px solid red';
      solved = false;
    }
  });

  if (solved) finishPuzzle();
}

function isSolved() {
  return cells.every((cell, i) =>
    +cell.firstChild.dataset.correct === i
  );
}

/* ===== –§–ò–ù–ò–® ===== */
function finishPuzzle() {
  stopTimer();
  message.textContent = '–ü–∞–∑–ª —Å–æ–±—Ä–∞–Ω! üéâ';
}

/* ===== –¢–ê–ô–ú–ï–† ===== */
function startTimer() {
  if (started) return;
  started = true;
  startTime = performance.now();

  timer = setInterval(() => {
    const t = performance.now() - startTime;
    const ms = Math.floor(t % 1000).toString().padStart(3, '0');
    const sec = Math.floor(t / 1000) % 60;
    const min = Math.floor(t / 60000);

    timerDisplay.textContent =
      `–í—Ä–µ–º—è: ${min}:${sec.toString().padStart(2,'0')}:${ms}`;
  }, 50);
}

function stopTimer() {
  clearInterval(timer);
}

function resetTimer() {
  clearInterval(timer);
  started = false;
  timerDisplay.textContent = '–í—Ä–µ–º—è: 0:00:000';
}

/* ===== –ü–†–ï–í–¨–Æ ‚Äî –¶–ï–õ–¨–ù–ê–Ø –ö–ê–†–¢–ò–ù–ö–ê ===== */
previewBtn.addEventListener('click', () => {
  if (!imageURL) return alert('–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ');
  previewPuzzle.innerHTML = '';
  const img = new Image();
  img.src = imageURL;
  img.style.width = `${cols * pieceWidth}px`;
  previewPuzzle.appendChild(img);
  previewContainer.style.display = 'block';
});

/* ===== TOUCH-DRAG SUPPORT (–¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö) ===== */
let touchDrag = {
  piece: null,
  srcCell: null,
  currentTargetCell: null
};

function onTouchStart(e) {
  e.preventDefault(); // —á—Ç–æ–±—ã –Ω–µ —Å–∫—Ä–æ–ª–ª–∏—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É –ø—Ä–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–∏
  const touch = e.changedTouches[0];
  const piece = e.currentTarget;
  touchDrag.piece = piece;
  touchDrag.srcCell = piece.parentElement;
  piece.classList.add('dragging');

  // –Ω–∞—á–∞—Ç—å —Ç–∞–π–º–µ—Ä, –µ—Å–ª–∏ –µ—â—ë –Ω–µ –Ω–∞—á–∞–ª–∏
  if (!started) startTimer();
}

function onTouchMove(e) {
  if (!touchDrag.piece) return;
  e.preventDefault();
  const touch = e.changedTouches[0];
  // —ç–ª–µ–º–µ–Ω—Ç –ø–æ–¥ –ø–∞–ª—å—Ü–µ–º
  const el = document.elementFromPoint(touch.clientX, touch.clientY);
  const cell = el ? el.closest('.cell') : null;
  if (cell !== touchDrag.currentTargetCell) {
    if (touchDrag.currentTargetCell) touchDrag.currentTargetCell.classList.remove('drop-target');
    touchDrag.currentTargetCell = cell;
    if (cell) cell.classList.add('drop-target');
  }
}

function onTouchEnd(e) {
  if (!touchDrag.piece) return;
  const piece = touchDrag.piece;
  const targetCell = touchDrag.currentTargetCell;
  piece.classList.remove('dragging');

  if (targetCell && targetCell !== touchDrag.srcCell) {
    const targetPiece = targetCell.firstChild;
    const srcCell = touchDrag.srcCell;

    // swap
    srcCell.appendChild(targetPiece);
    targetCell.appendChild(piece);

    if (enableCheck.checked) checkPositions();
    else if (isSolved()) finishPuzzle();
  }

  // –æ—á–∏—Å—Ç–∫–∞ –ø–æ–¥—Å–≤–µ—Ç–æ–∫
  document.querySelectorAll('.cell.drop-target').forEach(el => el.classList.remove('drop-target'));

  touchDrag.piece = null;
  touchDrag.srcCell = null;
  touchDrag.currentTargetCell = null;
}
</script>

</body>
</html>
